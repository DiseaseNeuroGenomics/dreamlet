% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mash.R
\name{run_mash}
\alias{run_mash}
\title{Run mash analysis on dreamlet results}
\usage{
run_mash(fit, coef)
}
\arguments{
\item{fit}{result from \code{dreamlet()}}

\item{coef}{coefficient to be analyzed}
}
\value{
a list storing the \code{mashr} model as \code{model} and the original coefficients as \code{logFC.original}
}
\description{
Run mash analysis on dreamlet results
}
\details{
Apply mashr analysis (Urbut, et al. 2019) on the joint set of coefficients for each gene and cell type.  Mashr is a Bayesian statistical method that borrows strength across tests (i.e. genes and cell types) by learning the distribution of non-zero effects based the obesrved logFC and standard errors.  The method then estimates the posterior distributions of each coefficient based on the observed value and the genome-wide emprical distribution.

In single cell data, a given gene is often not sufficiently expressed in all cell types.  So it is not evaluated in a subsets of cell types, and its coefficient value is NA. Since mashr assumes coefficients and standard errors for every gene and cell type pair, entries with these missing values are set to have \code{coef = 0}, and \code{se = 1e6}.  The output of mashr is then modified to set the corresponding values to NA, to avoid nonsensical results downstream.
}
\examples{
library(muscat)
library(mashr)
library(SingleCellExperiment)

data(example_sce)

# create pseudobulk for each sample and cell cluster
pb <- aggregateToPseudoBulk(example_sce, 
	assay = "counts",    
	cluster_id = 'cluster_id', 
	sample_id = 'sample_id',
	verbose=FALSE)

# voom-style normalization
res.proc = processAssays( pb, ~ group_id)

# Differential expression analysis within each assay,
# evaluated on the voom normalized data 
res.dl = dreamlet( res.proc, ~ group_id)

# run MASH model
# This can take 10s of minutes on real data
# This small datasets should take ~30s
res_mash = run_mash( res.dl, 'group_idstim')

# extract statistics from mashr model
# NA values indicate genes not sufficiently expressed
# in a given cell type

# original logFC
head(res_mash$logFC.original)

# posterior mean for logFC
head(get_pm(res_mash$model))

# how many gene-by-celltype tests are significant
# i.e.  if a gene is significant in 2 celltypes, it is counted twice
table(get_lfsr(res_mash$model) < 0.05, useNA="ifany")

# how many genes are significant in at least one cell type
table( apply(get_lfsr(res_mash$model), 1, min, na.rm=TRUE) < 0.05)

# how many genes are significant in each cell type
apply(get_lfsr(res_mash$model), 2, function(x) sum(x < 0.05, na.rm=TRUE))

# examine top set of genes
# which genes are significant in at least 1 cell type
sort(names(get_significant_results(res_mash$model)))[1:10]

# Lets examine CXCL3
# There is a lot of variation in the raw logFC
res_mash$logFC.original["ISG20",]

# posterior mean after borrowing across cell type and genes
get_pm(res_mash$model)["ISG20",]

# gene set analysis using mashr results
library(zenith)
go.gs = get_GeneOntology("CC", to="SYMBOL")
# valid values for statistic: 
# "tstatistic", "abs(tstatistic)", "logFC", "abs(logFC)"
df_gs = zenith_gsa(res_mash, go.gs)

# Heatmap of results
plotZenithResults(df_gs, 2, 1)

# forest plot based on mashr results
plotForest(res_mash, "ISG20")

# volcano plot based on mashr results
# yaxis uses local false sign rate (lfsr)
plotVolcano(res_mash)

}
\references{
{
  \insertRef{urbut2019flexible}{dreamlet}
}
}
\seealso{
\code{mashr::mash_estimate_corr_em()}, \code{mashr::cov_canonical}, \code{ mashr::mash_set_data}
}
